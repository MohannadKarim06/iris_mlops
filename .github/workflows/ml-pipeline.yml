name: Deploy BentoML Service

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: eu-north-1
  EKS_CLUSTER: iris-mlops-cluster

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.8'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
    
    - name: Initialize DVC
      run: |
        dvc init --no-scm || echo "DVC is already initialized"

    - name: Run Pipeline 
      run: |
        dvc repro
    
    - name: Build BentoML Service
      run: |
        # Build models first
        python scripts/build_bento.py
        
        # Navigate to bentoml directory
        cd bentoml
        
        # Copy required files
        cp ../requirements.txt .
        mkdir -p models
        cp -r ../models/* models/
        
        # Build only (no containerize)
        echo "Building BentoML service..."
        bentoml build
        
        cd ..

    - name: Build Custom Docker Image
      run: |
        # Copy Dockerfile to bentoml directory
        cp Dockerfile bentoml/
        
        # Build Docker image using our custom Dockerfile
        cd bentoml
        docker build -t iris_classifier_service:latest .
        
        # Tag the image for ECR
        docker tag iris_classifier_service:latest iris_classifier_service:${{ github.sha }}
        
        echo "Docker image built successfully"
        docker images | grep iris_classifier_service

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    
    - name: Build and push Docker image
      run: |
        # Tag for ECR
        ECR_URI="${{ steps.login-ecr.outputs.registry }}/iris-bentoml"
        docker tag iris_classifier_service:latest $ECR_URI:${{ github.sha }}
        docker tag iris_classifier_service:latest $ECR_URI:latest
        
        # Push to ECR
        docker push $ECR_URI:${{ github.sha }}
        docker push $ECR_URI:latest
        
        echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
    
    - name: Deploy to EKS
      run: |
        # Configure kubectl
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}
        
        # Get current AWS identity
        aws sts get-caller-identity
        
        # Add current IAM user to aws-auth ConfigMap for cluster access
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        IAM_USER_ARN="arn:aws:iam::${ACCOUNT_ID}:user/your-github-user-name"
        
        # Try to get existing aws-auth configmap
        kubectl get configmap aws-auth -n kube-system -o yaml > aws-auth.yaml || {
          echo "Creating new aws-auth ConfigMap"
          cat <<EOF > aws-auth.yaml
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: aws-auth
            namespace: kube-system
          data:
            mapUsers: |
              - userarn: ${IAM_USER_ARN}
                username: github-actions
                groups:
                  - system:masters
          EOF
                  }
        
        # Apply the aws-auth ConfigMap
        kubectl apply -f aws-auth.yaml
        
        # Wait a moment for permissions to propagate
        sleep 10
        
        # Test kubectl connection
        kubectl get nodes || { echo "kubectl authentication still failed"; exit 1; }
        
        # Create AWS secret for MLflow
        kubectl create secret generic aws-secret \
          --from-literal=access-key-id=${{ secrets.AWS_ACCESS_KEY_ID }} \
          --from-literal=secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
          --dry-run=client -o yaml | kubectl apply -f - || \
          kubectl create secret generic aws-secret \
            --from-literal=access-key-id=${{ secrets.AWS_ACCESS_KEY_ID }} \
            --from-literal=secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
        
        # Update image in deployment
        export ECR_IMAGE="${{ env.ECR_URI }}:${{ github.sha }}"
        export ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
        export IMAGE_TAG="${{ github.sha }}"
        envsubst < k8s/iris-service.yaml | kubectl apply -f -
        
        # Deploy other services
        kubectl apply -f k8s/prometheus.yaml
        kubectl apply -f k8s/grafana.yaml
        kubectl apply -f k8s/mlflow.yaml
        kubectl apply -f k8s/streamlit.yaml
        
        # Wait for deployment
        kubectl rollout status deployment/iris-service --timeout=300s
        
    - name: Get service URLs
      run: |
        echo "Waiting for LoadBalancer IPs..."
        sleep 60
        
        echo "ðŸš€ Service URLs:"
        echo "Iris API: http://$(kubectl get svc iris-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
        echo "Streamlit: http://$(kubectl get svc streamlit -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'):8501"
        echo "Grafana: http://$(kubectl get svc grafana -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'):3000"
        echo "Prometheus: http://$(kubectl get svc prometheus -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'):9090"
