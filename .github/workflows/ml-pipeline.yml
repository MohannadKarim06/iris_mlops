name: Deploy MLOps Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: eu-north-1
  EKS_CLUSTER: iris-mlops-cluster
  ECR_REPOSITORY: iris-bentoml

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: '3.8'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
    
    - name: Initialize DVC
      run: |
        dvc init --no-scm || echo "DVC is already initialized"

    - name: Run ML Pipeline 
      run: |
        dvc repro
    
    - name: Build BentoML Service
      run: |
        # Build models first
        python scripts/build_bento.py
        
        # Navigate to bentoml directory
        cd bentoml
        
        # Copy required files
        cp ../requirements.txt .
        mkdir -p models
        cp -r ../models/* models/
        
        # Build only (no containerize)
        echo "Building BentoML service..."
        bentoml build
        
        cd ..

    - name: Build Custom Docker Image
      run: |
        # Copy Dockerfile to bentoml directory
        cp Dockerfile bentoml/
        
        # Build Docker image using our custom Dockerfile
        cd bentoml
        docker build -t iris_classifier_service:latest .
        
        # Tag the image for ECR
        docker tag iris_classifier_service:latest iris_classifier_service:${{ github.sha }}
        
        echo "Docker image built successfully"
        docker images | grep iris_classifier_service

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    
    - name: Build and push Docker image
      run: |
        # Get ECR repository URI dynamically
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        ECR_URI="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
        
        docker tag iris_classifier_service:latest $ECR_URI:${{ github.sha }}
        docker tag iris_classifier_service:latest $ECR_URI:latest
        
        # Push to ECR
        docker push $ECR_URI:${{ github.sha }}
        docker push $ECR_URI:latest
        
        echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV
        echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
    
    - name: Install and Configure kubectl
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Configure kubectl
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}
        
        # Test connection
        kubectl get nodes
        
        echo "‚úÖ kubectl configured successfully"
    
    - name: Deploy to EKS
      run: |
        # Create AWS secret for MLflow
        kubectl create secret generic aws-secret \
          --from-literal=access-key-id=${{ secrets.AWS_ACCESS_KEY_ID }} \
          --from-literal=secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Get MLflow bucket name (assuming it follows the pattern)
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        # Try to find the bucket, or use a default pattern
        MLFLOW_BUCKET=$(aws s3api list-buckets --query "Buckets[?starts_with(Name, 'iris-mlflow-artifacts')].Name" --output text | head -1)
        if [ -z "$MLFLOW_BUCKET" ]; then
          echo "Warning: MLflow bucket not found, using default pattern"
          MLFLOW_BUCKET="iris-mlflow-artifacts-bucket"
        fi
        
        # Update image in deployment
        export ECR_IMAGE="${{ env.ECR_URI }}:${{ env.IMAGE_TAG }}"
        export ECR_REGISTRY="$ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        export IMAGE_TAG="${{ env.IMAGE_TAG }}"
        export MLFLOW_BUCKET_NAME="$MLFLOW_BUCKET"
        
        echo "üöÄ Deploying with image: $ECR_IMAGE"
        
        # Check if the image exists in ECR
        if aws ecr describe-images --repository-name iris-bentoml --image-ids imageTag=${{ env.IMAGE_TAG }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
          echo "‚úÖ Container image found in ECR"
        else
          echo "‚ùå Container image not found in ECR!"
          aws ecr describe-images --repository-name iris-bentoml --region ${{ env.AWS_REGION }} | head -20
        fi
        
        # Apply configurations with environment variable substitution
        echo "üì¶ Deploying iris-service..."
        envsubst < k8s/iris-service.yaml | kubectl apply -f -
        
        echo "üì¶ Deploying mlflow..."
        envsubst < k8s/mlflow.yaml | kubectl apply -f -
        
        # Deploy other services (no substitution needed)
        echo "üì¶ Deploying prometheus..."
        kubectl apply -f k8s/prometheus.yaml
        
        echo "üì¶ Deploying grafana..."
        kubectl apply -f k8s/grafana.yaml
        
        echo "üì¶ Deploying streamlit..."
        kubectl apply -f k8s/streamlit.yaml
        
        # Check initial deployment status
        echo "üìä Initial deployment status:"
        kubectl get deployments
        
        # Wait for deployment with better error handling
        echo "‚è≥ Waiting for iris-service deployment to complete..."
        
        # First, wait a reasonable time
        if kubectl rollout status deployment/iris-service --timeout=300s; then
          echo "‚úÖ Deployment completed successfully"
        else
          echo "‚ùå Deployment failed or timed out. Getting debug information..."
          
          # Debug information
          echo "üìä Deployment status:"
          kubectl describe deployment iris-service
          
          echo "üìä Pod status:"
          kubectl get pods -l app=iris-service -o wide
          
          echo "üìä Recent events:"
          kubectl get events --sort-by=.metadata.creationTimestamp --field-selector involvedObject.name=iris-service
          
          # Try to get logs from any running pods
          POD_NAME=$(kubectl get pods -l app=iris-service --no-headers | head -1 | awk '{print $1}' || echo "")
          if [ "$POD_NAME" != "" ]; then
            echo "üìã Pod logs for $POD_NAME:"
            kubectl logs $POD_NAME --tail=50 || echo "Could not retrieve logs"
          fi
          
          # Don't fail the build - continue to show service URLs
          echo "‚ö†Ô∏è Deployment issues detected but continuing to show service information"
        fi
    
    - name: Get service information
      run: |
        echo "üöÄ Deployment Status:"
        echo "===================="
        
        # Show deployment status
        kubectl get deployments
        echo ""
        
        # Show services
        kubectl get services
        echo ""
        
        # Show pods
        kubectl get pods
        echo ""
        
        echo "üîç Service URLs (may take a few minutes to be ready):"
        echo "=================================================="
        
        # Function to get LoadBalancer URL
        get_lb_url() {
          local service_name=$1
          local port=$2
          local hostname=$(kubectl get svc $service_name -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "pending")
          if [ "$hostname" != "pending" ] && [ "$hostname" != "" ]; then
            if [ "$port" != "" ]; then
              echo "http://${hostname}:${port}"
            else
              echo "http://${hostname}"
            fi
          else
            echo "Pending... (check again in a few minutes)"
          fi
        }
        
        echo "Iris API:    $(get_lb_url iris-service)"
        echo "Streamlit:   $(get_lb_url streamlit 8501)"
        echo "Grafana:     $(get_lb_url grafana 3000) (admin/admin123)"
        echo "Prometheus:  $(get_lb_url prometheus 9090)"
        echo "MLflow:      $(get_lb_url mlflow 5000)"
    
    - name: Test API endpoint
      run: |
        echo "‚è≥ Waiting for services to be ready..."
        sleep 120
        
        # Get the LoadBalancer hostname
        IRIS_LB=$(kubectl get svc iris-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
        
        if [ "$IRIS_LB" != "" ] && [ "$IRIS_LB" != "null" ]; then
          echo "üß™ Testing API endpoint: http://${IRIS_LB}"
          
          # Test health endpoint
          echo "Testing health endpoint..."
          curl -f "http://${IRIS_LB}/health" && echo "" || echo "Health check failed"
          
          # Test prediction endpoint
          echo "Testing prediction endpoint..."
          curl -X POST "http://${IRIS_LB}/predict_single" \
            -H "Content-Type: application/json" \
            -d '{"sepal_length": 5.1, "sepal_width": 3.5, "petal_length": 1.4, "petal_width": 0.2}' \
            && echo "" || echo "Prediction test failed"
            
          echo "‚úÖ API tests completed"
        else
          echo "‚ö†Ô∏è  LoadBalancer not ready yet. Check the service URLs manually in a few minutes."
        fi
        
        echo ""
        echo "üéâ MLOps pipeline deployment completed successfully!"
        echo "üìä Access your services using the URLs shown above."
